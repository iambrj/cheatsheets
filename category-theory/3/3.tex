\documentclass[titlepage, 12pt]{article}
\usepackage[parfill]{parskip}

\begin{document}

\title{Category Theory Unit 3}

\author{Bharathi Ramana Joshi}

\date{\today}

\maketitle

\newpage

\section{Book}

The set of morphisms from an object $a$ to object $b$ in a category $C$ is
called a \textbf{hom-set} and is written as $C(a, b)$ (or \textbf{Hom}$_C(a,
b)$)

\subsection{No Objects}

The most trivial category is one with zero objects and consequently zero
morphisms.

\subsection{Simple Graphs}

A directed graph can be made into a category by
\begin{enumerate}
	\item Adding an identity arrow at each node.
	\item For any two arrows such that the end of one coincides with the
		beginning of the other, add a new arrow to serve as their composition.
\end{enumerate}
Such a category is called a \textbf{free category} generated by a given graph.

\subsection{Orders}

\subsubsection{Pre order}
\begin{enumerate}
	\item Definition: a set with a relation that is reflexive and transitive.
	\item It is a category where there is at most one morphism from any object
		$a$ to any other object $b$ - such a category is called a \textbf{thin
		category}.
	\item Every hom-set is either empty or a singleton in preorder.
	\item There may be cycles in a preorder.
\end{enumerate}

\subsubsection{Partial order}
\begin{enumerate}
	\item Definition: a set with a relation that is reflexive, transitive and
		antisymmetric.
	\item Cycles are forbidden in a partial order.
	\item Partial orders can be sorted using topological sort.
\end{enumerate}

\subsubsection{Total order}
\begin{enumerate}
	\item Definition: a partial order which is connexive.
	\item Cycles are forbidden in a total order.
	\item Sorting algorithms can work correctly only on total orders.
\end{enumerate}

\subsection{Monoid}
\begin{enumerate}
	\item Definition: a Monoid is a set with a relation that is associative and
		has an identity.
	\item Type classes can be declared in Haskell for Monoids
		\begin{verbatim}
			class Monoid m where
			  mempty :: m
			  mappend :: m -> m -> m
		\end{verbatim}
		Note that it's the responsibility of the programmer to make sure that
		monoidal properties of \verb#mempty# and \verb#mappend#.
	\item Note that conceptually speaking,
		\begin{verbatim}
		mappend = (++)
		\end{verbatim}
		and
		\begin{verbatim}
		mappend s1 s2 = (++) s1 s2
		\end{verbatim}
		are different.

		The former is making equality of morphisms in the category
		\textbf{Hask}, but the latter is
		\textbf{extensional}/\textbf{point-wise} equality - stating that for any
		two strings, the outputs of
		\verb#mappend# and \verb#(++)# are the same.

	\item We can always extract a set from a single-object category - the set of
		morphisms which is a monoid (set of the functions from a set into itself
		form a monoid with respect to function composition).
\end{enumerate}

\end{document}

