git status #gives current status | -s for short
git add <file list> #add <file list> to staging area
git commit #commit files in staging area
.gitignore contains names of all files the aren't to be tracked
git commit -m "message"
git commit -v #verbose message containing git diff
git commit -a -m "message" #commit directly skipping staging area
git rm <file list> #not present in working dir, to be untracked
git rm --cached <file list> #present in working dir, but not to be tracked
git mv file_from file_to #rename
git log #show commit history
git log -p #patch i.e. difference between two versions
git log -n #shows n(some number) previous commits
git log --stat #show some statistics
git log --pretty=full/fuller/short/oneline
git log --since=2 years 1 day 3 minutes ago

To replace previous commit with an entirely new commit,
git commit -m 'initial commit'
git add forgotten_file
git commit --amend

git reset HEAD <file list> #remove files from staged area
git checkout -- <file list> #revert changes to files to previous commit
git remote -v #list all remote repos
git remote add <shortname> <url>
git fetch <shortname/url> #download data from remote repo
git pull #fetch and merge
git push <shortname> <branch>
git remote rename file_from file_to
git remote remove <shortname>
git tag #list all tags
git tag -l <regex>
git tag -a v1.0 -m 'my version 1.0'
git tag v1.0  #lightweighted tag
git tag -a v1.2 <checksum> #tag commit after commited
git show v1.0 #give details about commit referred to as v1.0
git push <shortname> <tags> #push tags onto remote repo
git checkout <version> #detached head, only access through commit hash
git checkout -b <branch name> <version> #create a branch instead
git config --global alias.co checkout #create alias co for config
