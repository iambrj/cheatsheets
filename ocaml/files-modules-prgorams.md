To compile an ocaml file

```
ocamlc freq.ml -o freq.byte
```

To link it with core

```
ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq.byte
``` 

Use corebuild, a simple wrapper around ocamlbuild sets pararmeters 
appropriately for building against Core and its related libraries:

```
corebuild freq.byte
```
Note that `freq.native` would have produced native code instead.

Module is a collection of definitions that are stored within a namespace.

By default, all code in a file is part of a module whose name is same as the 
file name with the first letter capitalized.

Implementation details of a module can be hidden by attaching an interface.

A module defined by a file `filename.ml` can be constrained by a signature
placed in a file called `filename.mli`

`ocamlbuild` will detect the presence of `mli` file automatically and includee
it in the build.

mli files can be autogenerated using `corebuild` as follows

```
corebuild conter.inferred.mli
cat _build/counter.inferred.mli
```

A type is abstract if its name is exposed in the interface, but its definition 
is not.
```
(** counter.mli **)

open Core.Std
(** A collection of string frequency counts **)
type t

(** The empty set of frequency counts **)
val empty : t

(** Bump the frequency count for the given string **)
val touch : t -> string -> t

(** Converts the set of frequency counts to an association list. A string shows
	up at most once, and the counts are >=1 **)
val to_list : t -> (string *int) list
```

`counter.ml` should be rewritten to match `counter.mli`
```
open Core.Std
type t = (string * int) list
let empty = []
let to_list x = x
let touch t s =
	let count =
		match List.Assoc.find t s with
		| None -> 0
		| Some x -> x
	in
	List.Assoc.add t s (count + 1)
```
